#ifndef __RPROCESS__H__
#define __RPROCESS__H__

#include <sys/stat.h>

#include "RHdr.h"
#include "RQueue.h"
#include "RState.h"

#define MAX_NAKS 30

#define HOSTING_ROOT "./"
#define HOSTING_ROOT_SZ 2

bool
set_fname(Data fname[MSG_SIZ], Data msg[MSG_SIZ])
{
	int ret = ~0;
	struct stat dat = {0};

	strcpy(fname, HOSTING_ROOT);
	memcpy(fname + HOSTING_ROOT_SZ, msg, MSG_SIZ - 2);
	fname[MSG_SIZ - 1] = '\0';
	
	ret = stat(fname, &dat);
	if (ret != 0) {
		fprintf(stderr, "stat: %d %s, {%s}\n", ret, strerror(errno), fname);
		return false;
	}
	return true;
}

/*
 * Got a new request in rstate->states[HIS]
 */
bool
rprocess_request(RState_p rstate)
{
	RHdr_p hdr_p = rhead_peak(&rstate->states[HIS]);
	char fname[MSG_SIZ] = {0};
	rstate->curr = rhead_peak_entry(&rstate->states[MYS]);

	// if (rstate->curr != NULL) { /* Convert the previous sent hdr back to host byte order */
	// 	convert_bytes(&rstate->curr->hdr, true);
	// }

	convert_bytes(hdr_p, true);
#ifdef DEBUG
	rhdr_pretty_print(hdr_p);
#endif
	if (rhead_check_seq(&rstate->states[HIS]) == false) {
		rhead_destroy_n_to_last(&rstate->states[HIS], hdr_p->content[SEQN] - 1);
		goto RET_PKT;
	}
	if (FLAG_VALIDATE((*hdr_p), ENC) == true) {
		decrypt(hdr_p);
	}
	if (FLAG_VALIDATE((*hdr_p), CHK) == true && valid_chksum(hdr_p) == false) {
		goto INVALID_NAK;
	}
	if (rstate->curr != NULL && FLAG_CHECK((*rhead_peak(&rstate->states[MYS])), NAK)) {
		rstate->naks += 1;
		rhead_destroy_n_to_last(&rstate->states[MYS], \
			rstate->curr->hdr.content[SEQN] - 1);
		rstate->curr = rhead_peak_entry(&rstate->states[MYS]);
		if (rstate->naks == MAX_NAKS) {
			return false;
		}
	}
	if (FLAG_CHECK((*hdr_p), NAK) == true && \
		rstate->curr != NULL) {
			/*
			 * NAK before GET respond NAK
			 * NAK after GET respond ACK if seq <= old_head->curr->seq
			 * NAK after GET respond NAK if seq > old_head->curr->seq
			 */
			RHdr_p old_hdr = rhead_peak(&rstate->states[MYS]);
			if (hdr_p->content[ACKN] < old_hdr->content[SEQN] && hdr_p->content[ACKN] > 0) {
				/* BAD */
			}
			if (old_hdr->content[SEQN] == hdr_p->content[ACKN]) {
				goto RET_PKT;
			}
			goto INVALID_NAK;
	}
	if (FLAG_CHECK((*hdr_p), GET) == true && rstate->curr == NULL) {
		if (set_fname(fname, hdr_p->msg) == false) {
			return false;
		}
		FILE *resource = fopen(fname, "r");
		if (resource == NULL) {
			return false;
		}
		Entry e = rstate->curr = rhead_append(&rstate->states[MYS]);
		FLAG_SET(e->hdr, DAT);
		fread(e->hdr.msg, 1, MSG_SIZ, resource);
		fclose(resource);
		rstate->request = hdr_p;
		rstate->ack = 1;
	} else if (FLAG_CHECK((*hdr_p), (ACK|DAT)) == true && \
		rstate->curr != NULL) {
		RHdr_p old_hdr = rhead_peak(&rstate->states[MYS]);
		if (old_hdr->content[SEQN] != hdr_p->content[ACKN]) {
			goto SND_PKT;
		}
		if (set_fname(fname, rstate->request->msg) == false) {
			return false;
		}
		FILE *resource = fopen(fname, "r");
		if (resource == NULL) {
			return false;
		}
		Entry e = rstate->curr = rhead_append(&rstate->states[MYS]);
		
		if (fseek(resource, rstate->ack * MSG_SIZ, SEEK_SET) < 0) {
			fprintf(stderr, "fseek: %d %s\n", errno, strerror(errno));
		}
		if (feof(resource) != 0) {
			FLAG_SET(e->hdr, FIN);
			fclose(resource);
			goto SND_PKT;
		}
		FLAG_SET(e->hdr, DAT);
		size_t read_bs = fread(e->hdr.msg, 1, MSG_SIZ, resource);
		if (read_bs == 0) {
			FLAG_VERSION_INIT(e->hdr);
			FLAG_SET(e->hdr, FIN);
			fclose(resource);
			goto SND_PKT;
		}
		fclose(resource);
		rstate->ack += 1;
	} else if (FLAG_CHECK((*hdr_p), (ACK|FIN)) == true && \
		rstate->curr != NULL) {
		RHdr_p old_hdr = rhead_peak(&rstate->states[MYS]);
		if (old_hdr->content[SEQN] != hdr_p->content[ACKN]) {
			goto SND_PKT;
		}
		Entry e = rstate->curr = rhead_append(&rstate->states[MYS]);
		FLAG_SET(e->hdr, ACK);
		FLAG_SET(e->hdr, FIN);
		if (FLAG_CHECK((*hdr_p), CHK) == true) {
			FLAG_SET(rstate->curr->hdr, CHK);
			rstate->curr->hdr.content[CHKS] = rhdr_computer_chksum(&rstate->curr->hdr);
		}
		if (FLAG_CHECK((*hdr_p), ENC) == true) {
			FLAG_SET(rstate->curr->hdr, ENC);
			encrypt(&rstate->curr->hdr);
		}
		rstate->curr->hdr.content[ACKN] = hdr_p->content[SEQN];
		printf("end\n");
		rstate->ack += 1;
		return false;
	} else {
INVALID_NAK:
		rstate->curr = rhead_append(&rstate->states[MYS]);
		FLAG_SET(rstate->curr->hdr, NAK);
		if (FLAG_CHECK((*hdr_p), CHK) == true) {
			FLAG_SET(rstate->curr->hdr, CHK);
			rstate->curr->hdr.content[CHKS] = rhdr_computer_chksum(&rstate->curr->hdr);
		}
	}
SND_PKT:
	if (FLAG_VALIDATE((*hdr_p), CHK) == true) {
		FLAG_SET(rstate->curr->hdr, CHK);
		rstate->curr->hdr.content[CHKS] = rhdr_computer_chksum(&rstate->curr->hdr);
	}
	if (FLAG_VALIDATE((*hdr_p), ENC) == true) {
		FLAG_SET(rstate->curr->hdr, ENC);
		encrypt(&rstate->curr->hdr);
	}
RET_PKT:
#ifdef DEBUG
	rhdr_pretty_print(&rstate->curr->hdr);
#endif
	//convert_bytes(&rstate->curr->hdr, false);
	//sleep(2);
	return true;
}

#endif //__RPROCESS__H__
