diff --git a/assn/2021/1/Makefile b/assn/2021/1/Makefile
index 1bc09b2..651ace5 100644
--- a/assn/2021/1/Makefile
+++ b/assn/2021/1/Makefile
@@ -1,6 +1,6 @@
 CXX=gcc
 CXXFLAGS=-Wall -Wextra -pedantic -g -ggdb# -DDEBUG
-LDD=-std=gnu99 -pthread
+LDD=-std=c99 -pthread
 
 BINS=main.exe RServer.exe RClient.exe
 
diff --git a/assn/2021/1/RHandleServ.h b/assn/2021/1/RHandleServ.h
index 36f0b07..add1e11 100644
--- a/assn/2021/1/RHandleServ.h
+++ b/assn/2021/1/RHandleServ.h
@@ -291,7 +291,7 @@ rhandle_port(char *buf, size_t len, \
 			errno, strerror(errno));
 		exit(EXIT_FAILURE);
 	}
-	bzero(curr, sizeof(*curr));
+	memset(curr, 0, sizeof(*curr));
 	RSTATE_INIT(curr->state);
 	pthread_mutex_init(&curr->lock, NULL);
 	curr->active[ONA] = true;
@@ -304,7 +304,7 @@ rhandle_port(char *buf, size_t len, \
 	prev = RB_FIND(rhandletree_port, p_tree, curr);
 	if (prev == NULL) { // curr inserted
 		curr->nreqs[MSG_PR] += 1;
-		bcopy(buf, curr->msg, len);
+		memcpy(curr->msg, buf, len);
 		curr->written = len;
 		curr->left = RHDR_SIZ - len;
 		curr->update_stamp[HIS] = \
@@ -315,12 +315,12 @@ rhandle_port(char *buf, size_t len, \
 		free(curr);
 		prev->nreqs[MSG_PR] += 1;
 		if (len >= RHDR_SIZ) {
-			bcopy(buf, prev->msg, len);
+			memcpy(prev->msg, buf, len);
 			prev->left = 0;
 			prev->written = RHDR_SIZ;
 		} else {
 			size_t space = (len > prev->left) ? prev->left : len;
-			bcopy(buf, (prev->msg + prev->written), space);
+			memcpy((prev->msg + prev->written), buf, space);
 			prev->left -= space;
 			prev->written += space;
 		}
@@ -341,7 +341,7 @@ rhandle_port(char *buf, size_t len, \
 	// if prev is full, handle the RHdr request
 	if (prev->left == 0 && prev->written == RHDR_SIZ) {
 		Entry e = rhead_append(&prev->state.states[HIS]);
-		bcopy(prev->msg, &e->hdr, RHDR_SIZ);
+		memcpy(&e->hdr, prev->msg, RHDR_SIZ);
 
 		if (rprocess_request(&prev->state) == false && \
 				prev->state.curr == NULL) {
@@ -382,7 +382,7 @@ rhandle_serv(char *buf, size_t len, \
 			"malloc: %d, %s", errno, strerror(errno));
 		exit(EXIT_FAILURE);
 	}
-	bzero(curr, sizeof(*curr));
+	memset(curr, 0, sizeof(*curr));
 	curr->ncons = 1;
 
 	// FORCE 0.0.0.0 to be 127.0.0.1
diff --git a/assn/2021/1/RHdr.h b/assn/2021/1/RHdr.h
index 82dc76e..4cc595f 100644
--- a/assn/2021/1/RHdr.h
+++ b/assn/2021/1/RHdr.h
@@ -25,7 +25,7 @@
 	hdr.content[FLGV] |= R_VERSION;
 
 #define RHDR_INIT(hdr) \
-	bzero(&hdr, sizeof(hdr)); \
+	memset(&hdr, 0, sizeof(hdr)); \
 	FLAG_VERSION_INIT(hdr);
 
 #define FLAG_SET(hdr, flag) \
@@ -41,7 +41,7 @@
 	(hdr.content[FLGV] & 7)
 
 #define RHDR_MSG_SET(hdr, msg_str, msg_len) \
-	bcopy(msg_str, hdr.msg, \
+	memcpy(hdr.msg, msg_str, \
                 (msg_len < MSG_SIZ) ? msg_len : MSG_SIZ)
 
 #define RHDR_CONTENT_SET(hdr, cno, val) \
diff --git a/assn/2021/1/RProcess.h b/assn/2021/1/RProcess.h
index 6fd77db..eac09b7 100644
--- a/assn/2021/1/RProcess.h
+++ b/assn/2021/1/RProcess.h
@@ -17,7 +17,7 @@ set_fname(Data fname[MSG_SIZ], Data msg[MSG_SIZ])
 	struct stat dat = {0};
 
 	strcpy(fname, HOSTING_ROOT);
-	bcopy(msg, fname + HOSTING_ROOT_SZ, MSG_SIZ - 2);
+	memcpy(fname + HOSTING_ROOT_SZ, msg, MSG_SIZ - 2);
 	fname[MSG_SIZ - 1] = '\0';
 	
 	ret = stat(fname, &dat);
diff --git a/assn/2021/1/RServer.c b/assn/2021/1/RServer.c
index bb450f9..cce5e3a 100644
--- a/assn/2021/1/RServer.c
+++ b/assn/2021/1/RServer.c
@@ -98,7 +98,7 @@ main(int argc, char *argv[])
 		exit(EXIT_FAILURE);
 	}
 
-	bzero(&ssock, sizeof(ssock));
+	memset(&ssock, 0, sizeof(ssock));
 	ssock.sin_family = AF_INET;
 	ssock.sin_port = htons(port);
 	ssock.sin_addr.s_addr = inet_addr(address);
diff --git a/assn/2021/1/main.c b/assn/2021/1/main.c
index 3807563..1af2fec 100644
--- a/assn/2021/1/main.c
+++ b/assn/2021/1/main.c
@@ -11,7 +11,7 @@ void
 run_timer(void)
 {
 	time_t update_stamp[2], now;
-	bzero(update_stamp, sizeof(update_stamp));
+	memset(update_stamp, 0, sizeof(update_stamp));
 
 	update_stamp[0] = time(NULL);
 
@@ -44,7 +44,7 @@ check_encryption(void)
 	// 	bytes[i] = i;
 	// }
 	// bytes[0] = (uint8_t)255;
-	bcopy(bytes, hdr.msg, MSG_SIZ);
+	memcpy(hdr.msg, bytes, MSG_SIZ);
 
 	//show_bytes(hdr.msg);
 	rhdr_computer_internal(&hdr, decrypt_);
